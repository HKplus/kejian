# 俄罗斯方块1

[toc]

俄罗斯方块是一款风靡全球的电视游戏机和掌上游戏机游戏，这款游戏最初是由 Alex Pajitnov 制作的，它看似简单但变化无穷，令人上瘾。

本节课将介绍使用「Python+Pygame」开发一个简单俄罗斯方块游戏的方法，并详细介绍其具体的实现流程。

# 规划图形

在本游戏项目中，主要用到了如下 4 类图形。

-   边框：由 10×20 个空格组成，方块就落在这里面。
-   盒子：组成方块的小方块，是组成方块的基本单元。
-   方块：从边框顶部掉下的东西，游戏者可以翻转和改变位置。每个方块由 4 个盒子组成。
-   形状：不同类型的方块，这里形状的名字分别称为 T、S、Z、J、L、I 和 O。在本实例中预先规划了如图所示的 7 种形状。
-   <img src="%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97-%E8%A7%84%E5%88%92%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96.assets/v2-ed2e4c3fcd476f61f9631f0f4dbef173_r.jpg" alt="2009" style="zoom:50%;" />

## 模板与着陆

除了准备上述 4 种图形外，还需要用到如下所示的两个术语。

1.  模板：用一个列表存放形状被翻转后的所有可能样式。所有可能的样式全部存放在变量里面，变量名字如 S_SHAPE_TEMPLATE 或 J_SHAPE_TEMPLATE。

2.  着陆（碰撞）：当一个方块到达边框的底部或接触到其他盒子时，我们称这个方块着陆了，此时另一个新的方块就会出现并开始下落。

# 具体实现

## 模块引入以及初始化

1.  首先使用` import`  语句引入 Python 的内置库和游戏库 `Pygame` ，然后定义一些项目用到的变量，并进行初始化工作。具体实现代码如下所示。

```python
# 导入对应模块
import random, time, pygame, sys 
from pygame.locals import *
# 设置刷新率
FPS = 25
# 设置宽高
WINDOWWIDTH = 640
WINDOWHEIGHT = 480
# 设置边框大小
BOXSIZE = 20
BOARDWIDTH = 10
BOARDHEIGHT = 20
BLANK = '.'
MOVESIDEWAYSFREQ = 0.15
MOVEDOWNFREQ = 0.1
XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2) 
TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5
#   R   G   B 
WHITE    = (255, 255, 255) 
GRAY     = (185, 185, 185) 
BLACK    = ( 0,  0,  0) 
RED       = (155,  0,  0) 
LIGHTRED  = (175, 20, 20) 
GREEN     = ( 0, 155,  0) 
LIGHTGREEN = ( 20, 175, 20) 
BLUE    = ( 0,  0, 155) 
LIGHTBLUE  = ( 20, 20, 175) 
YELLOW   = (155, 155,  0) 
LIGHTYELLOW = (175, 175, 20) 
BORDERCOLOR = BLUE 
BGCOLOR = BLACK 
TEXTCOLOR = WHITE 
TEXTSHADOWCOLOR = GRAY 
COLORS   = (   BLUE,   GREEN,   RED,   YELLOW) 
LIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) 
assert len(COLORS) == len(LIGHTCOLORS) # each color must have light color 
TEMPLATEWIDTH = 5
TEMPLATEHEIGHT = 5
```

>   在上述实例代码中，`BOXSIZE`、`BOARDWIDTH `和 `BOARDHEIGHT` 的功能是建立游戏与屏幕像素点之间的联系。
>
>   

   ```python
MOVESIDEWAYSFREQ = 0.15
MOVEDOWNFREQ = 0.1
   ```

通过使用上述两个变量，每当游戏玩家按下键盘中的左键或右键，下降的方块相应地向左或右移一个方块。另外，游戏玩家也可以一直按下左方向键或右方向键让方块保持移动。`MOVESIDEWAYSFREQ`  这个固定值表示如果一直按下左方向键或右方向键，那么方块每 `0.15s` 才 会继续移动一次。而 `MOVEDOWNFREQ`  这个固定值与上面的 `MOVESIDEWAYSFREQ ` 一样，功能是当游戏玩家一直按下下方向键时，表示方块下落的频率。

再看下面的两个变量，它们表示游戏界面的高度和宽度。

```python
XMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2)
TOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5
```

要想理解上述两个变量的含义，通过图 示的游戏界面会一目了然。

<img src="%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97-%E8%A7%84%E5%88%92%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96.assets/v2-014f8ffb7126f482cd6f8c86547593e2_r.jpg" alt="图片 13" style="zoom:50%;" />

2.  开始定义方块形状，分别定义了 T、S、Z、J、L、I 和 O 共计 7 种方块形状。具体实现代码如下所示。

```python
S_SHAPE_TEMPLATE = [['.....', 
                  '.....', 
                  '..OO.', 
                  '.OO..', 
                  '.....'], 
                 ['.....', 
                  '..O..', 
                  '..OO.', 
                  '...O.', 
                  '.....']] 

Z_SHAPE_TEMPLATE = [['.....', 
                  '.....', 
                  '.OO..', 
                  '..OO.', 
                  '.....'], 
                 ['.....', 
                  '..O..', 
                  '.OO..', 
                  '.O...', 
                  '.....']] 

I_SHAPE_TEMPLATE = [['..O..', 
                  '..O..', 
                  '..O..', 
                  '..O..', 
                  '.....'], 
                 ['.....', 
                  '.....', 
                  'OOOO.', 
                  '.....', 
                  '.....']] 

O_SHAPE_TEMPLATE = [['.....', 
                  '.....', 
                  '.OO..', 
                  '.OO..', 
                  '.....']] 

J_SHAPE_TEMPLATE = [['.....', 
                  '.O...', 
                  '.OOO.', 
                  '.....', 
                  '.....'], 
                 ['.....', 
                  '..OO.', 
                  '..O..', 
                  '..O..', 
                  '.....'], 
                 ['.....', 
                  '.....', 
                  '.OOO.', 
                  '...O.', 
                  '.....'], 
                 ['.....', 
                  '..O..', 
                  '..O..', 
                  '.OO..', 
                  '.....']] 

L_SHAPE_TEMPLATE = [['.....', 
                  '...O.', 
                  '.OOO.', 
                  '.....', 
                  '.....'], 
                 ['.....', 
                  '..O..', 
                  '..O..', 
                  '..OO.', 
                  '.....'], 
                 ['.....', 
                  '.....', 
                  '.OOO.', 
                  '.O...', 
                  '.....'], 
                 ['.....', 
                  '.OO..', 
                  '..O..', 
                  '..O..', 
                  '.....']] 

T_SHAPE_TEMPLATE = [['.....', 
                  '..O..', 
                  '.OOO.', 
                  '.....', 
                  '.....'], 
                 ['.....', 
                  '..O..', 
                  '..OO.', 
                  '..O..', 
                  '.....'], 
                 ['.....', 
                  '.....', 
                  '.OOO.', 
                  '..O..', 
                  '.....'], 
                 ['.....', 
                  '..O..', 
                  '.OO..', 
                  '..O..', 
                  '.....']]
```

3.  定义字典变量 PIECES 来存储所有的不同形状的模板，因为每个类型的方块又有它所有的变换形状，所以就意味着 PIECES 变量包含了每个类型的方块和所有的变换形状。该变量存放游戏中用到的形状的数据结构。具体实现代码如下所示。 


```python
def main(): 
global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT 
pygame.init() 
FPSCLOCK = pygame.time.Clock() 
DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) 
BASICFONT = pygame.font.Font('freesansbold.ttf', 18) 
BIGFONT = pygame.font.Font('freesansbold.ttf', 100) 
pygame.display.set_caption('Tetromino') 

#showTextScreen('Tetromino') 
while True: # game loop 
#if random.randint(0, 1) == 0: 
#pygame.mixer.music.load('tetrisb.mid') 
#else: 
#pygame.mixer.music.load('tetrisc.mid') 
#pygame.mixer.music.play(-1, 0.0) 
runGame() 
#pygame.mixer.music.stop() 
showTextScreen('Game Over')
```

上述代码中的 `runGame()`函数是核心，在循环中首先简单地随机决定采用哪个背景音乐。然后调用 `runGame()`函数运行游戏。当游戏失败时，`runGame()`就会返回 `main()`函数，这时会停止背景音乐和显示游戏失败的画面。当游戏玩家按下一个键时，函数 `showTextScreen()`会显示游戏失败，游戏循环会再次开始，然后继续下一次游戏。

